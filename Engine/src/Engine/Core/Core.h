//
// Created by phatt on 2/9/25.
//
#pragma once

/////////////////////////////////////////////////////////////////////////////////////////////
/// Include order matters here. /////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////
/// Logging /////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////

#include "Core/Log.h"

/////////////////////////////////////////////////////////////////////////////////////////////
/// Formatting Strings //////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////

#include "Core/DynamicFormat.h"

/////////////////////////////////////////////////////////////////////////////////////////////
/// Assertions //////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////

#include "Debug/Assert.h"
///
/////////////////////////////////////////////////////////////////////////////////////////////
/// Profiling ///////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////

#include "Debug/Instrumentor.h"

/////////////////////////////////////////////////////////////////////////////////////////////
/// Smart Pointers //////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////

namespace Engine
{
    template<typename T>
    using Ref = std::shared_ptr<T>;

    template<typename T>
    using Scope = std::unique_ptr<T>;

    template<typename T, typename... Args>
    Ref<T> CreateRef(Args&&... args)
    {
        return std::make_shared<T>(std::forward<Args>(args)...);
    }

    template<typename T>
    Ref<T> CreateRef(T* ptr)
    {
        return std::make_shared<T>(ptr);
    }

    template<typename T, typename... Args>
    Scope<T> CreateScope(Args&&... args)
    {
        return std::make_unique<T>(std::forward<Args>(args)...);
    }

    template<typename T>
    Scope<T> CreateScope(T* ptr)
    {
        return std::make_unique<T>(ptr);
    }
}

/////////////////////////////////////////////////////////////////////////////////////////////
/// Primitive Types /////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////

#include <cstdint>
#include <cfloat>

namespace Engine
{
    typedef std::int8_t     i8;
    typedef std::int16_t    i16;
    typedef std::int32_t    i32;
    typedef std::int64_t    i64;
    typedef std::uint8_t    u8;
    typedef std::uint16_t   u16;
    typedef std::uint32_t   u32;
    typedef std::uint64_t   u64;
    typedef std::float_t    f32;
    typedef std::double_t   f64;
}

/////////////////////////////////////////////////////////////////////////////////////////////
/// Utility /////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////

#define EG_BIT(x) (1 << (x))
#define EG_IM_UNUSED(_PARAM) ((void)_PARAM)

#ifdef ENGINE_FUNCTION_CURRYING_USE_LAMBDA
    #define EG_FORWARD_EVENT_TO_MEM_FN(fn) ([this](auto&& e) -> bool { return fn(std::forward<decltype(e)>(e)); })
#else
    #define EG_FORWARD_EVENT_TO_MEM_FN(fn) (std::bind(&(fn), this, std::placeholders::_1))
#endif





